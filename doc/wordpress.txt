[mathjax]

This project estimates the Mandelbrot set using the HTML5 canvas.  It's one of my longest running projects that has been implemented in PHP, SVG, HTML5 canvas, HTML tables, and even in ROOT.

<h3>Links</h3>

<a href="http://www.aidansean.com/mandelbrot/">Live page</a>
<a href="https://github.com/aidansean/mandelbrot">GitHub repository</a>

<h3>Overview</h3>

This projects presents a wide range of different challenges.  The aim is to create a fractal browser that pushes the operating environment to the limit in terms of performance, while still being user friendly and responsive.  In its current iteration the user clicks on the region of the fractal they wish to explore and the project zooms in to that region.  The user can change the way the fractal is coloured by changing the palette its properties.  They can also move from the Mandelbrot set to the corresponding Julia set.  There is also the option to explore the cubic Mandelbrot set.  Past iterations have included even more fractals, including Newton iterations and generalised Julia sets.  However these have been removed in this iteration as they should be refactored into a separate fractal class rather than inserted by hand.

<h3>Challenges</h3>
<dl>
<dt><em>Challenge</em>: The algorithm must be responsive and make reasonable use of memory.</dt>

<dd><em>Solution</em>: The iterations used in the algorithm can be expensive when the image approaches several hundred thousand pixels.  Currently the algorithm uses a pixel object to manage the colour at a given point, and for arbitrarily large images a single pixel object is used in order to reduce the cost of creating and storing large numbers of these objects.  The current iteration uses Javascript in the user's browser, and most modern browsers deal with excessive memory usage sensibly, killing particularly bad cases.  It is not desirable to cap a user's capabulities when it comes to image size, so instead the algorithm forces the browser to fail relatively safely and without major inconvenience.  Previously this project ran on PHP on a shared server, so memory use had to be monitored and was formally enforced on the server, making failure modes potentially dangerous.  Once the canvas became available I switched to using it very quickly.  Even so, running PHP locally overnight to generate very large images is still a sensible use of resounces.  There are probably other areas where savings could be made. (Resolved, to be revisited)</dd>
<dt><em>Challenge</em>: The algorithm must make reasonable use of CPU.</dt>

<dd><em>Solution</em>: In many cases the fractals take several tens of thousands of iterations per pixel for several thousand pixels, leading to large CPU usage.  In the context of Javascript this can cause serious performance issues for the user, affecting their whole computing experience and not just that associated with the browser session.  To mitigate this the iterations are interrupted every \(100 ms\) and forced to wait for \(10 ms\) before continuing.  In addition when several small canvases are populated they are pushed into a queue which is processed serially with interruptions.  This reduces the impact on the user's CPU significantly leading to much smoother performance and better response to user input.  Even so, this should be revisited to make further savings and be more responsive to the user's inputs. (Resolved, to be revisited)</dd>
<dt><em>Challenge</em>: The user interface must be intuitive.</dt>

<dd><em>Solution</em>: In some senses it will never be possible ot make the user interface entirely transparent, given the technical nature of the fractal's inner workings.  In spite of this the way the user navigates is relativelt straightforward, but more improvments can and should be made. (Resolved, to be revisited)</dd>
<dt><em>Challenge</em>: The palettes should be easy to edit.</dt>

<dd><em>Solution</em>: The asethetic properties of the fractals often depend on the choice of palette.  The palette scales can be manipulated, using slders on the log scale.  This solution borrows from another project being developed in parallel, and leads to an easier interpretation of the scaling and distorting of the palette scale.  This method should be tested in a "focus group" style environment.  The user should be able to create and store a palette from scratch with their own choice of colours stops. (Resolved, to be revisited)</dd>
<dt><em>Challenge</em>: The user should be able to store fractals.</dt>

<dd><em>Solution</em>: The user can currently choose to save a fractal to the server, storing the \((x,y)\) coordinates, zoom, and other factors.  This uses AJAX requests with a PHP and MySQL backend, which has become fairly standard in my projects by now.  This comes with the usual MySQL injection overheads and PHP safety issues.  In the future, as the number of fractals in the gallery increases, the gallery should be orgainsed in some manner to reduce bandwidth and CPU usage. (Resolved, to be revisited)</dd>
<dt><em>Challenge</em>: The project should support arbitrary fractals for future expansion.</dt>

<dd><em>Solution</em>: At the moment the fractal algorithms are hard coded into the project.  This needs to be more object oriented in the future so that other developers can contribute their own fractals. (Partially resolved, to be revisited)</dd>
</dl>